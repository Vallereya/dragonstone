use "modules/shared/toml/proc/lexer"
use "modules/shared/toml/proc/exception"
use "modules/shared/toml/proc/token"
use "modules/shared/toml/proc/string"

class TomlValueRecord
    property raw
    property is_static_array
    property kind

    def initialize(@raw, @kind)
        @is_static_array = false
    end

    def size
        case @kind
        when "array"
            @raw.size
        when "table"
            @raw.size
        else
            raise "Expected Array or Table for #size, not #{@kind}"
        end
    end

    def as_bool
        ensure_kind("bool")
        @raw
    end

    def as_i
        ensure_kind("int")
        @raw
    end

    def as_f
        ensure_kind("float")
        @raw
    end

    def as_s
        ensure_kind("string")
        @raw
    end

    def as_a
        ensure_kind("array")
        @raw
    end

    def as_h
        ensure_kind("table")
        @raw
    end

    def to_s
        @raw.to_s
    end

    def ensure_kind(expected)
        if @kind == expected
            return
        end

        raise "Expected #{expected}, not #{@kind}"
    end
end

class Parser
    def Hash()
        table = { "__toml_dummy__" -> nil }
        table.delete("__toml_dummy__")
        table
    end

    def self.parse(input)
        parser = Parser.new(input)
        parser.parse
    end

    def initialize(input)
        @lexer = Lexer.new(StringIO.new("#{input}"))
        @names = ""
        next_token
    end

    def parse
        root_table = Hash()
        @root_table = root_table
        table = root_table
        table_is_root = true

        while true
            case @lexer.token.type
            
            when :EOF
                break

            when :NEWLINE
                next_token

            when :KEY, :INT, :STRING
                parse_key_value(table, table_is_root)

                case @lexer.token.type

                when :NEWLINE
                    next_token

                when :EOF
                    # nothing

                else
                    unexpected_token

                end
            when "["
                table = parse_table_header(root_table)
                table_is_root = false

            else
                unexpected_token

            end
        end

        root_table
    end


    private def parse_key_value(root_table, is_root_table)
        @names = ""
        table = root_table
        key = nil
        current_is_root = is_root_table

        while true
            case @lexer.token.type

            when :KEY, :STRING, :INT
                name = @lexer.token.type == :INT ? @lexer.token.int_value.to_s : @lexer.token.string_value

                if @names == ""
                    @names = name
                else
                    @names = @names + "." + name
                end

                next_token

                if @lexer.token.type == "."
                    existing_value = table[name]

                    if existing_value
                        if existing_value.is_static_array
                            raise_error("Cannot append to static array")
                        end

                        if existing_value.kind == "table"
                            table = existing_value.raw
                            current_is_root = false
                        elsif existing_value.kind == "array"
                            last_element = existing_value.raw.last
                            if last_element
                                if last_element.kind == "table"
                                    table = last_element.raw
                                    current_is_root = false
                                else
                                    raise_error("expected #{@names} to be a Table of Array, not #{existing_value}")
                                end
                            else
                                new_table = Hash()
                                existing_value.raw.push(TomlValueRecord.new(new_table, "table"))
                                table = new_table
                                current_is_root = false
                            end
                        else
                            raise_error("expected #{@names} to be a Table, not #{existing_value}")
                        end
                    else
                        new_table = Hash()
                        if current_is_root
                            @root_table[name] = TomlValueRecord.new(new_table, "table")
                        else
                            table[name] = TomlValueRecord.new(new_table, "table")
                        end
                        table = new_table
                        current_is_root = false
                    end

                    next_token
                    if @lexer.token.type == "."
                        unexpected_token
                    end
                else
                    key = name
                    break
                end
            else
                unexpected_token
            end
        end

        check("=")
        next_token

        if table.has_key?(key)
            raise_error("duplicated key: '#{key}'")
        end

        value = parse_value
        value.is_static_array = value.kind == "array"
        table[key] = value
    end

    private def parse_key_value_after_key(table)
        parse_key_value(table, false)
    end

    private def parse_value
        value = nil
        value_kind = nil

        case @lexer.token.type
        when :KEY
            case @lexer.token.string_value
            when "true"
                next_token
                value = true
                value_kind = "bool"
            when "false"
                next_token
                value = false
                value_kind = "bool"
            else
                unexpected_token
            end
        when :INT
            value = @lexer.token.int_value
            value_kind = "int"
            next_token
        when :FLOAT
            value = @lexer.token.float_value
            value_kind = "float"
            next_token
        when :STRING
            value = @lexer.token.string_value
            value_kind = "string"
            next_token
        when "["
            value = parse_array
            value_kind = "array"
        when "{"
            value = parse_inline_table
            value_kind = "table"
        else
            unexpected_token
        end

        TomlValueRecord.new(value, value_kind)
    end

    private def parse_table_header(root_table)
        next_token

        if @lexer.token.type == "["
            next_token
            return parse_array_table_header(root_table)
        end

        names = parse_header_names(false)
        table = root_table
        current_is_root = true

        index = 0
        while index < names.size
            name = names[index]
            has_more_names = index < names.size - 1
            existing_value = table[name]

            if existing_value
                if existing_value.is_static_array
                    raise_error("Cannot append to static array")
                end

                if existing_value.kind == "table"
                    raw = existing_value.raw
                    if !has_more_names && !raw.empty?
                        raise_error("table #{@names} already defined")
                    end
                    table = raw
                    current_is_root = false
                elsif existing_value.kind == "array"
                    if has_more_names
                        array = existing_value.raw
                        last_element = array.last
                        if last_element && last_element.kind == "table"
                            table = last_element.raw
                            current_is_root = false
                        else
                            raise_error("expected #{@names} to be a Table of Array, not #{existing_value}")
                        end
                    else
                        raise_error("expected #{@names} to be a Table, not #{existing_value}")
                    end
                else
                    raise_error("expected #{@names} to be a Table, not #{existing_value}")
                end
            else
                new_table = Hash()
                if current_is_root
                    @root_table[name] = TomlValueRecord.new(new_table, "table")
                else
                    table[name] = TomlValueRecord.new(new_table, "table")
                end
                table = new_table
                current_is_root = false
            end

            index += 1
        end

        table
    end

    private def parse_array_table_header(root_table)
        names = parse_header_names(true)
        table = root_table
        current_is_root = true

        index = 0
        last_index = names.size - 1
        while index < names.size
            name = names[index]
            existing_value = table[name]

            if index == last_index
                if existing_value
                    if existing_value.is_static_array
                        raise_error("Cannot append to static array")
                    end

                    if existing_value.kind == "array"
                        array = existing_value.raw
                        new_table = Hash()
                        array.push(TomlValueRecord.new(new_table, "table"))
                        table = new_table
                        current_is_root = false
                    elsif existing_value.kind == "table"
                        raise_error("expected #{@names} to be an Array, not #{existing_value}")
                    else
                        raise_error("expected #{@names} to be an Array, not #{existing_value}")
                    end
                else
                    array = []
                    new_table = Hash()
                    array.push(TomlValueRecord.new(new_table, "table"))
                    if current_is_root
                        @root_table[name] = TomlValueRecord.new(array, "array")
                    else
                        table[name] = TomlValueRecord.new(array, "array")
                    end
                    table = new_table
                    current_is_root = false
                end
            else
                if existing_value
                    if existing_value.is_static_array
                        raise_error("Cannot append to static array")
                    end

                    if existing_value.kind == "table"
                        table = existing_value.raw
                        current_is_root = false
                    elsif existing_value.kind == "array"
                        array = existing_value.raw
                        if array.empty?
                            new_table = Hash()
                            array.push(TomlValueRecord.new(new_table, "table"))
                            table = new_table
                            current_is_root = false
                        else
                            last_table = array.last
                            unless last_table.kind == "table"
                                raise_error("expected #{@names} to be an Array of Table, not #{existing_value}")
                            end
                            table = last_table.raw
                            current_is_root = false
                        end
                    else
                        raise_error("expected #{@names} to be a Table, not #{existing_value}")
                    end
                else
                    new_table = Hash()
                    if current_is_root
                        @root_table[name] = TomlValueRecord.new(new_table, "table")
                    else
                        table[name] = TomlValueRecord.new(new_table, "table")
                    end
                    table = new_table
                    current_is_root = false
                end
            end
            index += 1
        end
        table
    end

    private def parse_header_names(double_ending)
        @names = ""
        names = []

        while true
            case @lexer.token.type
            when :KEY, :STRING, :INT
                name = @lexer.token.type == :INT ? @lexer.token.int_value.to_s : @lexer.token.string_value

                if @names == ""
                    @names = name
                else
                    @names = @names + "." + name
                end

                names.push(name)
                next_token

                case @lexer.token.type
                when "."
                    next_token
                    if @lexer.token.type == "."
                        unexpected_token
                    end
                when "]"
                    next_token

                    if double_ending
                        check("]")
                        next_token
                    end

                    case @lexer.token.type
                    when :EOF, :NEWLINE
                        return names
                    else
                        unexpected_token
                    end
                else
                    unexpected_token
                end
            else
                unexpected_token
            end
        end

        unexpected_token
    end


    private def parse_array
        next_token

        ary = []
        previous_kind = nil

        while true
            case @lexer.token.type
            when :NEWLINE
                next_token
                next
            when "]"
                next_token
                break
            else
                new_value = parse_value
                ary.push(new_value)

                if previous_kind && !same_type(previous_kind, new_value.kind)
                    raise_error("cannot mix types in array")
                end

                previous_kind = new_value.kind

                case @lexer.token.type
                when :NEWLINE
                    next_token
                    check("]")
                    next_token
                    break
                when ","
                    next_token
                when "]"
                    next_token
                    break
                else
                    raise_error("expected ',', ']' or newline, not #{@lexer.token}")
                end
            end
        end

        ary
    end

    private def parse_inline_table
        next_token

        table = Hash()

        while true
            case @lexer.token.type
            when :KEY, :STRING, :INT
                parse_key_value_after_key(table)

                if @lexer.token.type == ","
                    next_token
                end

                if @lexer.token.type == "}"
                    next_token
                    break
                end
            else
                unexpected_token
            end
        end

        table
    end

    # private def token
    #     @lexer.token
    # end

    private def next_token
        @lexer.next_token
    end

    private def same_type(a_kind, b_kind)
        a_kind == b_kind
    end

    private def check(token_type)
        unless token_type == @lexer.token.type
            raise_error("expecting token '#{token_type}', not '#{@lexer.token}'")
        end
    end

    private def raise_error(msg)
        raise "#{msg} at #{@lexer.token.line_number}:#{@lexer.token.column_number}"
    end

    private def unexpected_token
        raise_error("unexpected token '#{@lexer.token}'")
    end
end
