#[ 
    An Example of the Garbage Collection
]#

#[ 
    Function-level GC disable (@[gc.disable])

    Turn GC off for this function, use an Area for scratch work, 
    explicitly copy anything that needs to live on the GC heap, and then free the area-owned data.

    @[gc.disable] = GC will not run while this function executes. That’s fast but unsafe.
    Document.allocate(area) = Allocates in the Area, not on the GC heap.

    gc.copy(...) = Explicitly copies data from the area into GC-managed memory. 
    This is the only way data from a GC-off region is allowed to survive on the GC heap.

    doc.drop() = Deterministically frees area-owned resources for doc.
]#

# GC is disabled inside this function.
# This is inherently UNSAFE: you are responsible for memory usage and lifetimes.
@[gc.disable]
def build_cache(area: Area) : Map(int, Value)

    # Result lives on the GC heap and will survive after this function returns.
    let cache = Map(int, Value).new

    # Big scratch document allocated inside the area (not tracked by GC).
    let doc: @own Document = Document.allocate(area)

    # Heavy, allocation-heavy loop. All intermediates go through `doc`/`area`.
    1000000.times do |i|

        # Fill the arena-backed document with data for this key.
        doc.load_from_source(i)

        # Copy only what we actually want to keep into the GC heap.
        # `gc.copy` is the explicit boundary between area memory and GC memory.
        cache[i] = gc.copy(doc.to_value)

        # reuse the same arena storage for the next iteration
        doc.reset
    end

    # Free the area-owned document before we leave.
    doc.drop()

    # `cache` is GC-managed; safe to return even though GC was disabled here.
    return cache
end

#[ 
    Scoped GC area (@[gc.area])

    Create a temporary Area, allocate a whole level’s worth of data in it, 
    then either copy what you need or keep the whole Level in that area
]#

# This function demonstrates an explicit GC area (arena).
# All allocations made through `area` are freed together.
@[gc.area]
def load_level(path: str) : Level

    # Start a new area with an optional capacity hint.
    area = gc.begin(capacity: 64 * MB)

    # Allocate big blobs in the area (not GC-managed).
    let data     = area.allocate(bytes: 1000000)
    let textures = area.allocate(array: Texture, 256)

    # Fill area-backed buffers from disk or whatever source.
    load_level_data(path, data, textures)

    # You can create a GC-managed Level by copying out the pieces we want to keep.
    let level: Level = Level.allocate(
        data: gc.copy(data),
        meta: gc.copy(textures)
    )

    # Free all area-allocated memory in one shot.
    gc.end(area)

    # `level` is now fully GC-managed and safe to return.
    return level
end
