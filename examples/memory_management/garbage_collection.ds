#[

    #! WORK IN PROGRESS

    An Example of the Garbage Collection.

]#

#[

    Garbage Collection is currently experimental, 
    and is based off a simple boehm-style system,
    memory management strategy like Rust's arenas,
    Zig's allocators, and game engines use similar
    patterns.

    Annotations are used to control the interaction
    between the Garbage Collector and the Borrow Checker.

    The idea is to allow functions to disable GC when
    they need to do manual memory management, and to
    use Areas (Arenas) for bulk allocation of temporary
    data that can be discarded all at once.

    ## Function-level GC disable.
    @[Garbage(disable)] = GC will not run inside this function. 
    You’re responsible for not blowing RAM.
    Turn GC off for this function, use an Area for scratch work, 
    explicitly copy anything that needs to live on the GC heap, and 
    then free the area-owned data. This is inherently UNSAFE: you
    are responsible for memory usage and lifetimes.

    @[Garbage(enable)] = GC will run inside this function. 
    Alternatively, this is the default behavior.

    Document.allocate(area) = allocate into the Area instead of the GC heap.

    GC.escape(...) = explicitly move data from the Area into GC-managed memory.

    doc.drop() = deterministic cleanup of Area-backed resources.

    ## Crossing from Area to GC with GC.escape

    ## Using Areas (Arenas) for Bulk Allocation
    ## Batch allocations = allocate a bunch of stuff in an area, clear it all 
    at once (great for per-request, per-frame, per-function work).

    ## Predictable latency; no surprise GC pauses if you control areas manually.

    Annotations for controlling both GC and Borrow Checker, annotations can also be stacked:
        @[Garbage(enable)]
        @[Garbage(disable)]

        @[Ownership(enable)]
        @[Ownership(disable)]

        @[Ownership(enable) && Garbage(enable)]
        @[Ownership(disable) && Garbage(enable)]
        @[Ownership(enable) && Garbage(disable)]
        @[Ownership(disable) && Garbage(disable)]

        @[Garbage(enable) || Ownership(enable)]
        @[Garbage(disable) || Ownership(disable)]
        @[Garbage(enable) || Ownership(disable)]
        @[Garbage(disable) || Ownership(enable)]

        # Named areas for debugging.
        @[Garbage(area: "frame_processing")]

        # Explicit escape annotation for return values.
        @[Garbage(area, escape: return)]

        # Both.
        @[Garbage(area: "frame_processing", escape: return)]
        @[Garbage(area: "frame") && Ownership(enable)]

        # Multiple lines equivalent to &&
        @[Garbage(enable)]
        @[Ownership(enable)]

    annotation      = "@[" <memory_expr> "]"

    memory_expr     = memory_term (("&&" | "||") memory_term)*

    memory_term     =   "Garbage" "(" garbage_mode ")"
                        "Ownership" "(" <ownership_mode> ")"

    garbage_mode    =   "enable"
                        "disable"
                        "area"
                        "area:" <string>

    ownership_mode  =   "enable"
                        "disable"
    
]#

#[

    Example Usage

]#

@[Garbage(area)]
def tick_simulation
    # everything allocated here is in an area.
    # automatically cleared on return.
end

@[Garbage(area: "frame_processing")]
def process_frame

end

@[Garbage(area, escape: return)]
def compute_result
    data = heavy_computation()

    # 'data' escapes the area, not cleared.
    return data
end

# GC is disabled inside this function.
@[Garbage(disable)]
def build_cache(area: Area): Map(int, Value)

    # Result lives on the GC heap and will survive after this function returns.
    items = 1000000
    cache = Map(int, Value).new

    # Temporary document allocated inside the Area (not GC-managed).
    doc = Document.allocate(area)

    i = 0

    while i < items

        # Reuse the same area-backed document for each item.
        doc.reset
        doc.load_from_source(i)

        # Convert the document into a GC-managed value by copying.
    # GC.escape is the explicit boundary from Area memory -> GC heap.
    value = GC.escape(doc.to_value)
        cache[i] = value

        i += 1
    end

    # Explicitly free Area-owned resources held by `doc`.
    doc.drop

    # `cache` is GC-managed and safe to return even though GC was disabled.
    return cache
end

#[ 
    Scoped GC area (@[Garbage(area)])

    Create a temporary Area, allocate a whole level’s worth of data in it, 
    then either copy what you need or keep the whole Level in that area
]#

# This function demonstrates an explicit GC area (arena).
# This function uses a transient Area (arena) to load a level efficiently.
@[Garbage(area)]
def load_level(path: str): Level

    # Start a new Area. Optional capacity hint for performance.
    area = GC.begin_area

    # Allocate big blobs in the Area (not on the GC heap).
    data = area.allocate(bytes: 1000000)
    textures = area.allocate(array: Texture, 256)

    # Fill the Area-backed buffers from disk or some other source.
    load_level_data(path, data, textures)

    # Create a GC-managed Level by copying the pieces we want to keep.
    level = Level.new(
        data: GC.escape(data),
        textures: GC.escape(textures)
    )

    # Free everything allocated in this Area in a single operation.
    GC.end_area(area)

    # `level` is now fully GC-managed and safe to return.
    return level
end

# Zero-copy variant: Level lives in the Area.
# Caller is responsible for calling GC.end_area(area) when done.
@[Garbage(area)]
def load_level_in_area(path: str): Tuple(Area, Level)
    area = GC.begin_area

    data = area.allocate(bytes: 1000000)
    textures = area.allocate(array: Texture, 256)

    load_level_data(path, data, textures)

    # Level is built directly in the Area.
    level = Level.allocate(area, data, textures)

    # Do NOT GC.end_area(area) here; the caller owns the Area lifetime.
    return { area, level }
end

# GC is disabled inside this function (once attribute support exists).
def build_cache(area): Map(int, Value)
    cache = []                         # GC-managed
    doc   = Document.allocate(area)    # arena-managed

    i = 0
    while i < 1_000_000
        doc.load_from_source(i)
        cache[i] = GC.escape(doc.to_value)
        doc.reset
        i += 1
    end

    doc.drop
    cache
end

def load_level(path: str): Level
    area = GC.begin_area

    data     = area.allocate(bytes: 1_000_000)
    textures = area.allocate(array: Texture, count: 256)
    load_level_data(path, data, textures)

    level = Level.allocate(
        data: GC.escape(data),
        meta: GC.escape(textures)
    )

    GC.end_area(area)
    level
end

# Example of combining Ownership and Garbage Collection annotations.
#! BORROW CHECKER HAS NOT BEEN IMPLEMENTED YET.
#[
@[Garbage(enable) && Ownership(enable)]
def process(data: &mut Buffer)  # borrowed mutably
    temp = data.slice(0, 100)   # temp borrows from data
    
    result = compute(temp)      # ownership: temp still valid
                                # gc: result tracked in case it escapes
    return result               # ownership: result moves out
                                # gc: escapes current scope, promoted
end

@[Garbage(enable) || Ownership(enable)]
def flexible_func(data)
    # Compiler: if ownership can prove safety, no GC tracking
    # Runtime: if ownership can't prove it, GC kicks in
end

@[Garbage(disable) && Ownership(disable)]
def unsafe_ffi_call(ptr: *void, len: int)
    # No safety nets
    # You must manually free anything allocated
    # Useful for: FFI, embedded, real-time guarantees
end

# With both gc and bc.
@[Garbage(disable) && Ownership(enable)]
def Load(area: Area): Level
    let doc: @own Document = Document.allocate(area)
    
    do
        let editor: &mut Document = &mut doc
        editor.append("Hello")
    end

    alias data = doc.data
    alias meta = doc.meta

    let level: Level = Level.allocate(
        data: GC.escape(data),
        meta: GC.escape(meta)
    )

    doc.drop()
    return level
end
]#
